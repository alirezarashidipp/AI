import os
import uuid
import ssl
import logging
import asyncio
from typing import List, Optional
from pydantic import BaseModel, Field

import httpx
import truststore
from openai import AsyncOpenAI
from token_jwt import get_token

truststore.inject_into_ssl()

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class TicketEvaluation(BaseModel):
    has_what: bool
    has_who: bool
    has_why: bool
    has_ac: bool
    is_ready_for_refinement: bool
    missing_elements_feedback: str

class LLMClientManager:
    _instance: Optional[AsyncOpenAI] = None

    @classmethod
    def get_client(cls) -> AsyncOpenAI:
        if cls._instance is None:
            ctx = truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
            httpx_client = httpx.AsyncClient(
                http2=True,
                verify=ctx,
                timeout=httpx.Timeout(90.0, connect=5.0),
                limits=httpx.Limits(max_keepalive_connections=50, max_connections=100)
            )
            cls._instance = AsyncOpenAI(
                api_key=os.getenv("OPENAI_API_KEY", "dummy_key"),
                http_client=httpx_client,
                base_url=os.getenv("ENTERPRISE_LLM_BASE_URL", "https://api.enterprise.com/v1")
            )
        return cls._instance

class JiraRefinementAgent:
    def __init__(self, model_name: str = None):
        self.client = LLMClientManager.get_client()
        self.model = model_name or os.getenv("ENTERPRISE_MODEL_NAME", "gpt-4o")
        self.messages: List[dict] = [
            {
                "role": "system",
                "content": "Lead Agile TPM. Analyze Jira tickets for Who, What, Why, and AC. Ask for missing info. If complete, rewrite as professional Markdown."
            }
        ]

    async def get_headers(self):
        return {
            "X-HSBC-E2E-Trust-Token": get_token(),
            "x-correlation-id": str(uuid.uuid4()),
            "x-usersession-id": str(uuid.uuid4())
        }

    async def evaluate_state(self) -> TicketEvaluation:
        headers = await self.get_headers()
        completion = await self.client.beta.chat.completions.parse(
            model=self.model,
            messages=self.messages,
            response_format=TicketEvaluation,
            temperature=0.0,
            extra_headers=headers
        )
        return completion.choices[0].message.parsed

    async def generate_final_ticket(self) -> str:
        headers = await self.get_headers()
        self.messages.append({"role": "user", "content": "Generate final Jira description."})
        completion = await self.client.chat.completions.create(
            model=self.model,
            messages=self.messages,
            temperature=0.2,
            extra_headers=headers
        )
        return completion.choices[0].message.content

    async def run(self, initial_input: str):
        self.messages.append({"role": "user", "content": initial_input})
        
        for _ in range(5):
            state = await self.evaluate_state()
            
            if state.is_ready_for_refinement:
                final_output = await self.generate_final_ticket()
                print(f"\nFINAL TICKET:\n{final_output}")
                return

            print(f"\nAGENT: {state.missing_elements_feedback}")
            user_response = input("USER: ")
            
            if user_response.lower() in ['exit', 'quit']:
                break
                
            self.messages.append({"role": "user", "content": user_response})

if __name__ == "__main__":
    agent = JiraRefinementAgent()
    asyncio.run(agent.run("We need to update the database schema for the user service."))
